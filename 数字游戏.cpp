#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
int result=0;
int main()
{
	int a[1005];
	int n;
	std::cin>>n;
	int miss=0;
	for(int i=0;i<n;i++)
	{
		std::cin>>a[i];
	}
	std::sort(a,a+n);
	for(int i=0;i<n;i++)
	{
		//std::cout<<miss<<std::endl;
		if(a[i]>miss+1)
			break;
		miss+=a[i];
	}
	std::cout<<miss+1<<std::endl;
}
/*
从小到大排序，一开始一块钱都凑不出来
下面，为了0~x都有，我需要来一个1元的（不然1元凑不出来）
给了你1元的，下面必须给1+1元以内的，不然2元凑不出来
如果再给一个1元的，那你现在能凑出0~2元的，接下来+1+2或者+3，都能增大范围而且不会导致中间缺一个数（4元的不行，因为凑不出3了）
——反正一直往下，直到出现第一个算不出来的值为止。
*/
/*
/**
 * 背包问题的一种，本质为"若num小于不可解的最小数，那么1,2,3...num都是可解的"。
 *
 * 思路如下：
 *
 * 将给定的数据集nums从大到小排序。我们要判断命题"num小于不可解的最小数"是否成立。
 * 我们将num看作背包，然后从nums中拿出一个最大的值v，如果num中能够放得下就放进去，
 * 如果放进去后刚好满了，则num可解，命题成立，如果不满继续迭代；如果v放不进去背包中了，
 * 那么背包剩下的容量构成一个更小的子问题(<num)，并且如果想要命题成立，那么该子问题
 * 必定可解，并且解必定由v后边的数字序列构成(已从大到小排序)。
 */